# 第二阶段扩展说明

## 实现的功能

第二阶段基础需求：
* 你需要提交第一阶段的main.cpp，并保证仍能通过第一阶段的测试（占5%）
* 实现用于调试的Assert运算、实现捆绑Bind运算（占5%）
* 实现链式求导功能（占10%）
* 实现牛顿迭代法解方程（占5%）

第二阶段拓展需求：
* 实现给Variable赋值的Assign运算（最多+10%）
* 实现完整的自动求导功能，需要支持的运算符有-，/，sin，exp，log，Print，Assert，Bind，比较运算符（最多+10%）
* 运算图的session和存取功能，实现session与parameter值的绑定 (最多+10%)；并能够从文件存储和读取session中的parameter的值（最多+5%）
* 实现梯度下降求优化最小二乘法对于自变量有多个的情况（最多+20%)

需求以外的功能：
* 允许测试一次eval里涉及2次求导，允许求高阶导
* 添加了cos函数
* 实现了cos，tanh，sigmoid，assign，cond的自动求导功能

所有实现的功能都有对应测试数据，在`test/`目录下。

### 求导

对计算图进行拓扑排序后，按照拓扑序依次处理每个节点。每个节点实现自己的`propagate_grad`函数，用于将自己的偏导传播给自己依赖的节点。当一个节点的所有前驱节点都向自己贡献过之后，再处理自己。这部分在`Gradient_Node.cpp`中的`Gradient_Node::Gradient_Node`函数中实现。

对于一些特殊函数的求导处理：
* Print: 由于这个操作返回数本身，所以求导时认为print与单位函数e(x)=x无异；
* Logic: 由于逻辑运算符的输出是分段的，在很多位置的导数未定义；另外，输入在小范围内变动对logic输出无影响；故认为求导结果总是返回0；
* Condition: 条件语句将根据求导时的条件结果决定导数是否为0；如`a?sin(b):c`对b求导的结果在a>0时为cos(b)，在a<=0时，因为输出的值与b无关，对b求导的值为0；对a求导的值与Logic类似，总为0。

基本需求中的求导测试使用了下发样例；扩展需求中所有可求导的函数的单元测试在`test/stage2/more_grad`中。

### 牛顿迭代法

有一些导数为0的情况。对于这些情况，程序会放弃迭代并直接使用上一次迭代的值作为当前迭代的答案。有相应测试数据`test/newton/corner_cases/divide_zero`。

有时牛顿迭代法不一定能找到解（如无解的一元二次方程），这时牛顿迭代法会在极值左右震荡。见`test/newton/corner_cases/oscillate`。

### Session

Session类存储了Variable名字到float的映射。Session类实现了标准库的istream和ostream来负责输入输出，配合fstream可以非常方便地存储到文件或从文件读取。当然也可以使用sstream来将session序列化。

在`Graph`类中，`Graph::save`将数据存储到`Session`，`Graph::restore`从`Session`中恢复数据。

在测试时，我们给主程序添加了`SAVEFILE {filename}`和`READFILE {filename}`两个命令，分别表示将当前的variable存入和读取到文件中。相应测试数据在`test/stage2/session`中。

#### Session在一些特殊情况下的行为

Session只存储当前名字有效的Variable。如果一个Variable的名字被覆盖，那么它不会被存储进Session中。

_我们考虑过使用指针作为identifier，但这样存储的session在当前程序结束之后就失效了。使用名字作为identifier已经能实现所有功能，所以我们没有考虑其他的方案。_

## 对原库实现的更改

以下是我们对第二阶段原库实现的更改内容。我们的实现优先少改接口，其次少改实现。但因为原库的实现**bug较多**，我们不得不做了一些改动。

另外，为了实现扩展功能，我们新增了一些接口，具体在代码上的改动可以[使用git查看对比](https://github.com/sshockwave/OOP-ComputationalGraph1/compare/2.0.0-alpha...master)。

### 输入输出部分

原库将输入和输出封装在了库中，而主程序仅仅是简单地调用了库的几个接口。因此，我们第一、第二阶段的主程序完全相同。

我们需要添加功能时，只能修改库的`creat_nodes`、`commands`、`crossroad`、`initialize_operator`系列函数。

### 缓存清空问题

在原库的实现中，缓存清空(clear_buffer)是递归进行的，而这个递归过程没有记忆化。

举例说明：对于以下一张图，
```
a0=1
a1=a0+a0
a2=a1+a1
```
清空a2时，会递归清空a1两次，而每清空一次a1都要递归清空a0两次。这样清空的复杂度很容易就被卡到指数级。要保持原有clear_buffer不变的含义不变，我们提出了三种方案：

* 进行全局清空或在全局存储需要局部清空的节点；
* 引入一个新的time tag来标记是否已经清空；
* 引入一个“已清空”标记；更绕的是，这个“已清空”标记本身还需要清空……这个方案不可行。

考虑另外一个问题：在原库的实现中，进行完一轮计算并进行清空的时候，是沿着计算的target回去清空的。如果某个placeholder的值没有被target所依赖，那么placeholder就不会被清空。这在placeholder给充分的条件下不会出问题，但如果在某些询问中，placeholder没给全，那这个程序就不能正常地报出“placeholder missing”错误。

但为了尽量减少对原库的改动，在我们的实现中并没有选择新增time tag，而是进行了全局清空。`Graph::reset_state`表示清空整张图，`Basic_Node::reset_state`表示清空该节点。对于一些不应该被清空的节点（如`Constant_Node`），它们重载了`reset_state`。

### 内存回收问题

在Graph类的initialize_operator系列函数中，原库对垃圾回收的解决意图为：如果有名字覆盖现象，那么就将旧节点放入`abandoned`列表。

原库的实现却不是这么一回事。原库进行的判断是，如果运算的节点和新节点同名，那么将运算的节点放入`abandoned`列表中。比如`a = a + b`中，右边的`a`会被放入`abandoned`列表中。

但是对于以下计算图：
```
a = 3
b = a + a
a = b * b
```
原来的`a=3`就没有被放入`abandoned`列表。

另外，Data_Node又负责了释放内存，这与Operation_Node的功能不一致，易造成混乱。而在后面的实现中Gradient_Node又不知道返回的节点会被谁使用，因此也决定不了谁回收。这样不一致的行为若不修改，只能在新增的库中增加大量对外部的特判，导致耦合性大大增强。

我们的解决方案为，将所有的节点资源交由Graph来释放。在新建节点的时候，就在Graph中注册这个节点；在Graph被销毁的时候，Graph将释放`abandoned`和`item`中的所有指针。这些指针不能有重复。

这部分新增了若干接口`add_node`、`set_new_item`，并对原库的实现进行了较大的修改，主要体现在创建并存储节点的`initialize_operator`的系列函数中。但是原有接口的signature和含义都没有变化。

### 计算图结构

通过对原库代码的阅读，发现每一个节点在加进Graph中之前，都在外面套了一层placeholder。这层placeholder起到了几个作用：防止变量重复计算、给变量赋予名字。这么设计的好处似乎在于不需要对每个Operation Node都实现`get_name`、`get_type`函数。但是这样会给性能大打折扣，Placeholder的作用也十分模糊。

为了最小化对原库的变更，我们并没有更改原库的这一架构。但是在我们拓展的Gradient_Node中，我们省略了这一层placeholder，没有与原库保持一致。
