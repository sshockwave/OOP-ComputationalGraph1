排名：AEDB

A:
优点：
    使用了很多c++的特性：
        try，catch，exception来处理异常，简洁明了；
        命名空间的使用避免命名重复；
        智能指针的使用使内存管理更简洁；
        node相关的结构比较符合OOP的特点，有扩展性
        symbol实现了唯一标签，
缺点：
    说明文档不够详细；
    部分结构有一些混乱，节点计算时用expression来包装不明白它的好处，反而增大了扩展的难度；
    visted与version两个标记作用有重叠，两者各自的作用不清晰；
    用占手动实现了递归计算eval，初衷是好，避免栈空间不够，但是UOJ本身对栈空间没有特殊限制，栈空间问题也有其他解决方法。这样做反而让程序简洁，也不利于维护和扩展；
    有滥用map的嫌疑，很多地方map是完全不必要的；
    计算结果的记录是在主程序中实现的，没有封装到类中；
    部分函数程序中没有使用到，也没说清楚可能的用法和设置这些函数的目的；

B:
优点：
    注释、说明文档清晰明了。
    读入采用了getline，再对字符串进行分割，效率更高。
缺点：
    输入语句封装在pc类中，不利于扩展和使用。
    使用固定大小的数组存放result（每次运算的结果)和pois（每个节点），扩展性差且有安全隐患。
    point一个类承担所有类型（placeholder、constant、variable、operation）的功能，层次不分明，难以扩展。
    point类中所有数据都是公有成员，数据得不到隐藏。
    每次进行EVAL操作时都需要对ifcal进行还原，繁琐且效率底下。

D：
优点：
    框架清晰，结构简明，可读性强。
    将重命名结点置于另一个vector中，解决了内存泄漏的问题。
    有debug代码，方便调试。
缺点：
    将输入语句封装在Graph内，虽然使main函数简洁，但不利于扩展和使用。
    Graph类内实现了string-to-int函数，在STL中已有同样功能函数，重复累赘。
    将Variable_Node声明为Graph的友元，破坏了整体结构和封装性，应考虑在Variable类中提供相应接口。
    每次执行EVAL操作时都需要使用clear-buffer还原，效率较低。
    报错机制是return nullptr，如果中途出现错误，仍需要一层层回溯回去，效率低，且每次执行EVAL函数时都需要先判断是否返回空指针，代码冗余。
    错误信息分散在程序各处，不利于代码维护，应考虑将异常集中处理。
    用于存放执行结果的map<int,float>answers，完全可以用查找效率更高的vector替代。
    对重名结点的处理过于繁琐，代码膨胀且降低了可读性。

E：
优点：  
    将数据储存到一个计算图中，方便进行多个计算图的运算。
    用宏定义的方式实现类似虚函数的函数，简化代码，避免了许多重复的派生和函数。
    value类储存了数据的类型，方便于应用到不仅是float类型的数据中
  

缺点：
    在多种输入错误的情况下仅有一种错误提示方式，不利于查错  
    value.cpp内仅有一个构造函数，不妨将其放到头文件 
    不建议graph中友元的使用，可以创造对应的接口
    读入时的分割采用stringstream可以更为简洁
    parser中的setmod来进行赋值运算等操作不如直接执行对应的函数？
    文档是英文的
