代码评价  A E D C B

A 
优点：
1.运用了大量的STL中已有的函数，有利于简化代码。在该组的错误处理十分简明，值得学习。2.通过Smybol类的构建，保证了密集图的算法效率。

缺点：
1.对于父类的利用不充分，Expression、Placeholder、Constant、Variable四个类都为Node的子类，但是Graph中分别使用了四个map分别存储着四个类型的点，还用了两组函数来进行操作，函数的实现方法是定义一个模板函数来对四个函数分别进行实现，个人认为这里应该充分利用Node类来完成这一操作。也有利于后续增加新的类。

看似是基于linnux 可移植性更好 doc写得清楚
使用了看不懂的API环境变量 
智能指针 未见核查其局限性
错误机制 抛出？
这三个类的对象均可以转为Expression对象以支持在Expression上定义好的加减乘除等运算。  不如直接是node？
——两套Node::getAllPreq和Node::getPreq分离，支持不同图结构 
一个Expression和一个Placeholder，两种是分开的，比较麻烦了
实现了栈运算  提供debug功能 宏定义变量类型

B
代码评价：
优点：1.实现方法比较粗暴简单，整体思路容易理解；
缺点：1.其实我感觉这就是个FOP，只是把一些函数封装起来了，全部的实现和字符串处理并没有本质上的区别；2.代码处理不够明智，推荐使用vector来代替result[6000]这样的表达，推荐使用stringstream来进行字符串的处理；3.输出结果没有保留四位小数，不符合题目的基本要求。

C
评价：
优点：1.各个类的继承关系比较合理，对父类的利用程度较高（如一、二、三元运算符类写了关于求值的方法，而具体的计算方法是在子类中具体实现的），由此一来可以减少代码量，可拓展性较强。2.利用栈处理有依赖关系的结点，有利于实现复杂表达式的处理。3.报错采用了throw，较清晰明了。4.改组对于指针的删除做的较好，较好的保证了内存不泄露也防止了重复释放带来的程序崩溃。
几点异议：1.在实现减少重复计算的功能时，用了两个变量、两个函数，处理的过程相对来说较为繁琐。2.关于该组的附加功能：该组实现了新的计算符，这个没有问题，但是该组增加了较多的新的操作，个人认为相当于自己当了自己的甲方（就是感觉有些不妥，但不存在什么问题）。3.该组在node（最基本的类）中重载+-*/，但实际上在之后的操作很少有应用，导致该重载操作显得多余。

E 
可拓展性：
在value.h中给出 `dtype`, `shape` and `stype`预留拓展空间是比较好的。

性能：
报错使用抛出机制，写起来很方便，但是效率会相应变低，建议为提高性能手动编写这种跳出的机制。

结构： 
class Graph当中使用Node*  而且声明friend class Node; 
而class Node使用Graph &graph 声明friend class Graph; 代码耦合度比较高；总体功能实现中总是在传Graph &graph，感觉不够oop。
不必要区别fathers和ancestors，同理，children和descendants，因为造成整体Node的结构过于复杂，且不方便统一描述使用。。例如，ancestors是用来区分Placeholder类型的前驱，而fathers是其他的前驱，可以对Placeholder加一个属性值用以区分就行。

代码简洁性：
MathFunc中大量使用含参宏定义，可以使不同的具体运算符操作的类定义书写更为简便。MathFunc中大量使用含参宏定义，可以使不同的具体运算符操作的类定义书写更为简便。
其中，
#define _SIGMOID(x) 1 / (1 + exp(-x))
#define _TANH(x) (exp(x) - exp(-x)) / (exp(x) + exp(-x))
建议最外层再加一对括号避免将来可能出现的bug。

整体评价：
整体逻辑清晰，代码量比较精简，可读性较高，可拓展性较好；建议结构上为便于后续简单开发再调整一些划分。
