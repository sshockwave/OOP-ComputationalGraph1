## 计算图结构

通过对原库代码的阅读，发现每一个节点在加进Graph中之前，都在外面套了一层placeholder。这层placeholder起到了几个作用：防止变量重复计算、给变量赋予名字。这么设计的好处似乎在于不需要对每个Operation Node都实现`get_name`、`get_type`函数。但是这样会给性能大打折扣，Placeholder的作用也不明确了。

但为了原代码库的兼容性，我们并没有更改这一架构。

## 求导

对计算图进行拓扑排序后，按照拓扑序依次处理每个节点。每个节点实现自己的`propagate_grad`函数，用于将自己的偏导传播给自己依赖的节点。当一个节点的所有前驱节点都向自己贡献过之后，再处理自己。这部分在`Gradient_Node.cpp`中的`Gradient_Node::Gradient_Node`函数中实现。

对于一些特殊函数的求导处理：
* Print: 由于这个操作返回数本身，所以求导时认为print与单位函数e(x)=x无异；
* Logic: 由于逻辑运算符的输出是分段的，在很多位置的导数未定义；另外，输入在小范围内变动对logic输出无影响；故认为求导结果总是返回0；
* Condition: 条件语句将根据求导时的条件结果决定导数是否为0；如`a?sin(b):c`对b求导的结果在a>0时为cos(b)，在a<=0时，因为输出的值与b无关，对b求导的值为0；对a求导的值与Logic类似，总为0。

## 牛顿迭代法

有一些导数为0的情况。对于这些情况，程序会放弃迭代并直接使用上一次迭代的值作为当前迭代的答案。有相应测试数据`test/newton/corner_cases/divide_zero`。

有时牛顿迭代法不一定能找到解（如无解的一元二次方程），这时牛顿迭代法会在极值左右震荡。见`test/newton/corner_cases/oscillate`。

## 缓存清空问题

在原库的实现中，缓存清空是递归进行的，而这个递归过程没有记忆化。

举例说明：对于以下一张图，
```
a0=1
a1=a0+a0
a2=a1+a1
...
```
这样清空的复杂度很容易就被卡到指数级。要保持原有clear_buffer不变的含义不变，我们提出了三种方案：

* 进行全局清空或在全局存储需要局部清空的节点；
* 引入一个新的time tag来标记是否已经清空；
* 引入一个“已清空”标记；更绕的是，这个“已清空”标记本身还需要清空……这个方案不可行。

考虑到另外一个问题，在原库的实现中，进行完一轮计算并进行清空的时候，是沿着计算的target回去清空的。如果某个placeholder的值没有被target所依赖，那么placeholder就不会被清空。这在placeholder给充分的条件下不会出问题，但如果在某些询问中，placeholder没给全，那这个程序就不能正常地报出“placeholder missing”错误。

但为了尽量减少对原库的改动，在我们的实现中并选择新增time tag，而是进行了全局清空。`Graph::reset_state`表示清空整张图，`Basic_Node::reset_state`表示清空该节点。对于一些不会被清空的节点（如`Constant_Node`），它们重载了`reset_state`，防止自身被清空。

## 内存回收问题

在Graph类的initialize_operator系列函数中，调整了设置item的方式。原本的实现只是判断了会不会覆盖当前表达式中的节点；若之前还有同名节点，那些节点不会被添加进abandoned列表中，会有内存泄漏问题。

另外，Data_Node又负责了释放内存，这与Operation_Node的功能不一致，易造成混乱。而在后面的实现中Gradient_Node又不知道返回的节点会被谁使用，因此也决定不了是要自己负责回收，还是交给Graph回收，还是交给调用者回收。这样不一致的行为若不修改，只能在新增的库中增加大量对外部的特判，导致耦合性大大增强。

因此，改为使用工厂模式：实例因为哪个类需要，就由哪个类负责销毁。
如Graph类中的initialize_operator函数中创建了一些operator node，那么在Graph类被销毁的时候由Graph来负责销毁这些operator node。
又如Data_Node中的prev_Operation本来就是在外部创建的，所以Data_Node也不应该负责销毁，故删去了销毁。

虽然修改了库的部分已有实现，但是并未改变库的接口。
