## 牛顿迭代法

除了样例以外，还有一些导数为0的情况。对于这些情况，程序会放弃迭代并直接使用上一次迭代的值作为当前迭代的答案。有相应测试数据`test/newton/corner_cases/divide_zero`。
## 对原库的更改

### 内存问题

在Graph类的initialize_operator系列函数中，调整了设置item的方式。原本的实现只是判断了会不会覆盖当前表达式中的节点；若之前还有同名节点，那些节点不会被添加进abandoned列表中，会有内存泄漏问题。

另外，Data_Node又负责了释放内存，这与Operation_Node的功能不一致，易造成混乱。而在后面的实现中Gradient_Node又不知道返回的节点会被谁使用，因此也决定不了是要自己负责回收，还是交给Graph回收，还是交给调用者回收。这样不一致的行为若不修改，只能在新增的库中增加大量对外部的特判，导致耦合性大大增强。

因此，改为使用工厂模式：实例因为哪个类需要，就由哪个类负责销毁。
如Graph类中的initialize_operator函数中创建了一些operator node，那么在Graph类被销毁的时候由Graph来负责销毁这些operator node。
又如Data_Node中的prev_Operation本来就是在外部创建的，所以Data_Node也不应该负责销毁，故删去了销毁。

虽然修改了库的部分已有实现，但是并未改变库的接口。
